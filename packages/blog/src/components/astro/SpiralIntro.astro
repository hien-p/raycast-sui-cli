---
/**
 * Spiral Animation Intro - Full Astro/Vanilla JS Version
 *
 * A full-screen cinematic intro with canvas spiral animation.
 * Uses vanilla JS + GSAP to avoid React hydration issues in Astro.
 *
 * Shows once per post visit (uses postId to track), with skip button and auto-dismiss.
 */
interface Props {
  title?: string;
  duration?: number;
  postId?: string;
}

const { title = "Loading...", duration = 4000, postId } = Astro.props;
const words = title.split(' ');
// Generate a unique ID from title if postId not provided
const uniqueId = postId || title.toLowerCase().replace(/[^a-z0-9]+/g, '-').slice(0, 50);
---

<div id="spiral-intro-overlay" class="spiral-overlay" data-duration={duration} data-post-id={uniqueId}>
  <!-- Canvas for Spiral Animation -->
  <canvas id="spiral-canvas" class="spiral-canvas"></canvas>

  <!-- Dark overlay for better text readability -->
  <div class="dark-overlay"></div>

  <!-- Content -->
  <div class="intro-content">
    <!-- Decorative Line -->
    <div class="decorative-line" id="deco-line"></div>

    <!-- Subtitle -->
    <p class="subtitle" id="subtitle">◈ Loading Article</p>

    <!-- Title -->
    <h1 class="title">
      {words.map((word, i) => (
        <span class="word" data-index={i} style={`transition-delay: ${i * 40}ms;`}>
          {word}
        </span>
      ))}
    </h1>

    <!-- Progress Bar -->
    <div class="progress-container" id="progress-container">
      <div class="progress-track">
        <div class="progress-bar" id="progress-bar" style={`animation-duration: ${duration}ms;`}></div>
      </div>
      <p class="progress-text">PREPARING CONTENT</p>
    </div>
  </div>

  <!-- Skip Button -->
  <button class="skip-btn" id="skip-btn">Skip →</button>
</div>

<style>
  .spiral-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #000;
    z-index: 99999;
    overflow: hidden;
    opacity: 1;
    transition: opacity 800ms ease-out;
  }

  .spiral-overlay.fading {
    opacity: 0;
    pointer-events: none;
  }

  .spiral-overlay.hidden {
    display: none !important;
  }

  /* Canvas - full screen behind everything */
  .spiral-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  /* Dark overlay for better text contrast */
  .dark-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(
      135deg,
      rgba(0, 0, 0, 0.6) 0%,
      rgba(0, 0, 0, 0.3) 50%,
      rgba(0, 0, 0, 0.5) 100%
    );
    z-index: 2;
  }

  /* Content positioned on left side */
  .intro-content {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding-left: clamp(2rem, 8vw, 6rem);
    padding-right: 2rem;
    max-width: 60%;
    z-index: 10;
  }

  /* Decorative Line */
  .decorative-line {
    width: 0;
    height: 1px;
    background-color: rgba(255,255,255,0.4);
    margin-bottom: 24px;
    transition: width 0.8s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .decorative-line.visible {
    width: 60px;
  }

  /* Subtitle */
  .subtitle {
    color: rgba(255,255,255,0.5);
    font-size: clamp(0.65rem, 1.5vw, 0.8rem);
    font-family: ui-monospace, monospace;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    margin-bottom: 16px;
    margin-top: 0;
    opacity: 0;
    transform: translateY(15px);
    transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .subtitle.visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* Title */
  .title {
    color: white;
    font-size: clamp(1.5rem, 4vw, 3rem);
    font-family: Georgia, serif;
    font-weight: 400;
    letter-spacing: -0.02em;
    line-height: 1.2;
    margin: 0;
    text-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
  }

  .word {
    display: inline-block;
    margin-right: 0.25em;
    opacity: 0;
    transform: translateX(40px);
    filter: blur(4px);
    transition: all 0.7s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .word.visible {
    opacity: 1;
    transform: translateX(0);
    filter: blur(0px);
  }

  /* Progress Container */
  .progress-container {
    margin-top: 40px;
    width: clamp(150px, 20vw, 250px);
    opacity: 0;
    transition: opacity 0.8s ease 0.3s;
  }

  .progress-container.visible {
    opacity: 1;
  }

  .progress-track {
    height: 2px;
    background-color: rgba(255,255,255,0.15);
    border-radius: 2px;
    overflow: hidden;
  }

  .progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,255,255,0.4));
    animation: progressFill cubic-bezier(0.16, 1, 0.3, 1) forwards;
  }

  @keyframes progressFill {
    from { width: 0%; }
    to { width: 100%; }
  }

  .progress-text {
    color: rgba(255,255,255,0.35);
    font-size: 0.65rem;
    font-family: ui-monospace, monospace;
    margin-top: 8px;
    margin-bottom: 0;
    letter-spacing: 0.1em;
  }

  /* Skip Button */
  .skip-btn {
    position: absolute;
    bottom: clamp(1.5rem, 4vh, 2.5rem);
    right: clamp(1.5rem, 4vw, 2.5rem);
    color: rgba(255,255,255,0.5);
    font-size: 0.7rem;
    font-family: ui-monospace, monospace;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    padding: 10px 20px;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 100px;
    background: rgba(255,255,255,0.05);
    backdrop-filter: blur(8px);
    cursor: pointer;
    z-index: 20;
    opacity: 0;
    transition: all 0.4s ease;
  }

  .skip-btn.visible {
    opacity: 1;
  }

  .skip-btn:hover {
    color: rgba(255,255,255,0.8);
    background: rgba(255,255,255,0.1);
    border-color: rgba(255,255,255,0.35);
  }
</style>

<script>
  // Load GSAP dynamically
  async function loadGSAP() {
    if (typeof window !== 'undefined' && !(window as any).gsap) {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js';
      script.async = true;
      document.head.appendChild(script);

      return new Promise<void>((resolve) => {
        script.onload = () => resolve();
      });
    }
    return Promise.resolve();
  }

  // Vector classes
  class Vector2D {
    constructor(public x: number, public y: number) {}
    static random(min: number, max: number): number {
      return min + Math.random() * (max - min);
    }
  }

  class Vector3D {
    constructor(public x: number, public y: number, public z: number) {}
  }

  // Star class for particle system
  class Star {
    private dx: number;
    private dy: number;
    private spiralLocation: number;
    private strokeWeightFactor: number;
    private z: number;
    private angle: number;
    private distance: number;
    private rotationDirection: number;
    private expansionRate: number;
    private finalScale: number;

    constructor(cameraZ: number, cameraTravelDistance: number) {
      this.angle = Math.random() * Math.PI * 2;
      this.distance = 30 * Math.random() + 15;
      this.rotationDirection = Math.random() > 0.5 ? 1 : -1;
      this.expansionRate = 1.2 + Math.random() * 0.8;
      this.finalScale = 0.7 + Math.random() * 0.6;

      this.dx = this.distance * Math.cos(this.angle);
      this.dy = this.distance * Math.sin(this.angle);

      this.spiralLocation = (1 - Math.pow(1 - Math.random(), 3.0)) / 1.3;
      this.z = Vector2D.random(0.5 * cameraZ, cameraTravelDistance + cameraZ);

      const lerp = (start: number, end: number, t: number) => start * (1 - t) + end * t;
      this.z = lerp(this.z, cameraTravelDistance / 2, 0.3 * this.spiralLocation);
      this.strokeWeightFactor = Math.pow(Math.random(), 2.0);
    }

    render(p: number, controller: SpiralController) {
      const spiralPos = controller.spiralPath(this.spiralLocation);
      const q = p - this.spiralLocation;

      if (q > 0) {
        const displacementProgress = controller.constrain(4 * q, 0, 1);

        const linearEasing = displacementProgress;
        const elasticEasing = controller.easeOutElastic(displacementProgress);
        const powerEasing = Math.pow(displacementProgress, 2);

        let easing;
        if (displacementProgress < 0.3) {
          easing = controller.lerp(linearEasing, powerEasing, displacementProgress / 0.3);
        } else if (displacementProgress < 0.7) {
          const t = (displacementProgress - 0.3) / 0.4;
          easing = controller.lerp(powerEasing, elasticEasing, t);
        } else {
          easing = elasticEasing;
        }

        let screenX, screenY;

        if (displacementProgress < 0.3) {
          screenX = controller.lerp(spiralPos.x, spiralPos.x + this.dx * 0.3, easing / 0.3);
          screenY = controller.lerp(spiralPos.y, spiralPos.y + this.dy * 0.3, easing / 0.3);
        } else if (displacementProgress < 0.7) {
          const midProgress = (displacementProgress - 0.3) / 0.4;
          const curveStrength = Math.sin(midProgress * Math.PI) * this.rotationDirection * 1.5;

          const baseX = spiralPos.x + this.dx * 0.3;
          const baseY = spiralPos.y + this.dy * 0.3;
          const targetX = spiralPos.x + this.dx * 0.7;
          const targetY = spiralPos.y + this.dy * 0.7;

          const perpX = -this.dy * 0.4 * curveStrength;
          const perpY = this.dx * 0.4 * curveStrength;

          screenX = controller.lerp(baseX, targetX, midProgress) + perpX * midProgress;
          screenY = controller.lerp(baseY, targetY, midProgress) + perpY * midProgress;
        } else {
          const finalProgress = (displacementProgress - 0.7) / 0.3;
          const baseX = spiralPos.x + this.dx * 0.7;
          const baseY = spiralPos.y + this.dy * 0.7;

          const targetDistance = this.distance * this.expansionRate * 1.5;
          const spiralTurns = 1.2 * this.rotationDirection;
          const spiralAngle = this.angle + spiralTurns * finalProgress * Math.PI;

          const targetX = spiralPos.x + targetDistance * Math.cos(spiralAngle);
          const targetY = spiralPos.y + targetDistance * Math.sin(spiralAngle);

          screenX = controller.lerp(baseX, targetX, finalProgress);
          screenY = controller.lerp(baseY, targetY, finalProgress);
        }

        const vx = (this.z - controller.cameraZ) * screenX / controller.viewZoom;
        const vy = (this.z - controller.cameraZ) * screenY / controller.viewZoom;

        const position = new Vector3D(vx, vy, this.z);

        let sizeMultiplier = 1.0;
        if (displacementProgress < 0.6) {
          sizeMultiplier = 1.0 + displacementProgress * 0.2;
        } else {
          const t = (displacementProgress - 0.6) / 0.4;
          sizeMultiplier = 1.2 * (1.0 - t) + this.finalScale * t;
        }

        const dotSize = 8.5 * this.strokeWeightFactor * sizeMultiplier;
        controller.showProjectedDot(position, dotSize);
      }
    }
  }

  // Main spiral animation controller
  class SpiralController {
    private timeline: any;
    public time = 0;
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private size: number;
    private stars: Star[] = [];

    // Constants
    private readonly changeEventTime = 0.32;
    public readonly cameraZ = -400;
    public readonly cameraTravelDistance = 3400;
    private readonly startDotYOffset = 28;
    public readonly viewZoom = 100;
    private readonly numberOfStars = 5000;
    private readonly trailLength = 80;

    constructor(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, size: number) {
      this.canvas = canvas;
      this.ctx = ctx;
      this.size = size;

      this.setupRandomGenerator();
      this.createStars();
    }

    private setupRandomGenerator() {
      const customRandom = () => {
        let seed = 1234;
        return () => {
          seed = (seed * 9301 + 49297) % 233280;
          return seed / 233280;
        };
      };

      const originalRandom = Math.random;
      Math.random = customRandom();
      this.stars = [];
      for (let i = 0; i < this.numberOfStars; i++) {
        this.stars.push(new Star(this.cameraZ, this.cameraTravelDistance));
      }
      Math.random = originalRandom;
    }

    private createStars() {
      // Stars are created in setupRandomGenerator
    }

    startAnimation(gsap: any) {
      this.timeline = gsap.timeline({ repeat: -1 });
      this.timeline.to(this, {
        time: 1,
        duration: 15,
        repeat: -1,
        ease: "none",
        onUpdate: () => this.render()
      });
    }

    // Easing functions
    ease(p: number, g: number): number {
      if (p < 0.5) return 0.5 * Math.pow(2 * p, g);
      return 1 - 0.5 * Math.pow(2 * (1 - p), g);
    }

    easeOutElastic(x: number): number {
      const c4 = (2 * Math.PI) / 4.5;
      if (x <= 0) return 0;
      if (x >= 1) return 1;
      return Math.pow(2, -8 * x) * Math.sin((x * 8 - 0.75) * c4) + 1;
    }

    map(value: number, start1: number, stop1: number, start2: number, stop2: number): number {
      return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
    }

    constrain(value: number, min: number, max: number): number {
      return Math.min(Math.max(value, min), max);
    }

    lerp(start: number, end: number, t: number): number {
      return start * (1 - t) + end * t;
    }

    spiralPath(p: number): Vector2D {
      p = this.constrain(1.2 * p, 0, 1);
      p = this.ease(p, 1.8);
      const numberOfSpiralTurns = 6;
      const theta = 2 * Math.PI * numberOfSpiralTurns * Math.sqrt(p);
      const r = 170 * Math.sqrt(p);

      return new Vector2D(
        r * Math.cos(theta),
        r * Math.sin(theta) + this.startDotYOffset
      );
    }

    showProjectedDot(position: Vector3D, sizeFactor: number) {
      const t2 = this.constrain(this.map(this.time, this.changeEventTime, 1, 0, 1), 0, 1);
      const newCameraZ = this.cameraZ + this.ease(Math.pow(t2, 1.2), 1.8) * this.cameraTravelDistance;

      if (position.z > newCameraZ) {
        const dotDepthFromCamera = position.z - newCameraZ;
        const x = this.viewZoom * position.x / dotDepthFromCamera;
        const y = this.viewZoom * position.y / dotDepthFromCamera;
        const sw = 400 * sizeFactor / dotDepthFromCamera;

        this.ctx.lineWidth = sw;
        this.ctx.beginPath();
        this.ctx.arc(x, y, 0.5, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    private drawStartDot() {
      if (this.time > this.changeEventTime) {
        const dy = this.cameraZ * this.startDotYOffset / this.viewZoom;
        const position = new Vector3D(0, dy, this.cameraTravelDistance);
        this.showProjectedDot(position, 2.5);
      }
    }

    render() {
      const ctx = this.ctx;
      if (!ctx) return;

      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, this.size, this.size);

      ctx.save();
      ctx.translate(this.size / 2, this.size / 2);

      const t1 = this.constrain(this.map(this.time, 0, this.changeEventTime + 0.25, 0, 1), 0, 1);
      const t2 = this.constrain(this.map(this.time, this.changeEventTime, 1, 0, 1), 0, 1);

      ctx.rotate(-Math.PI * this.ease(t2, 2.7));

      this.drawTrail(t1);

      ctx.fillStyle = 'white';
      for (const star of this.stars) {
        star.render(t1, this);
      }

      this.drawStartDot();
      ctx.restore();
    }

    private drawTrail(t1: number) {
      for (let i = 0; i < this.trailLength; i++) {
        const f = this.map(i, 0, this.trailLength, 1.1, 0.1);
        const sw = (1.3 * (1 - t1) + 3.0 * Math.sin(Math.PI * t1)) * f;

        this.ctx.fillStyle = 'white';
        this.ctx.lineWidth = sw;

        const pathTime = t1 - 0.00015 * i;
        const position = this.spiralPath(pathTime);

        this.ctx.beginPath();
        this.ctx.arc(position.x, position.y, sw / 2, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    destroy() {
      if (this.timeline) {
        this.timeline.kill();
      }
    }
  }

  // Main initialization
  async function initSpiralIntro() {
    const overlay = document.getElementById('spiral-intro-overlay');
    if (!overlay) return;

    // Always show animation on every visit (no session storage check)

    const duration = parseInt(overlay.dataset.duration || '4000', 10);
    const words = overlay.querySelectorAll('.word');
    const decoLine = document.getElementById('deco-line');
    const subtitle = document.getElementById('subtitle');
    const progressContainer = document.getElementById('progress-container');
    const skipBtn = document.getElementById('skip-btn');

    // Initialize canvas
    const canvas = document.getElementById('spiral-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Handle DPR
    const dpr = window.devicePixelRatio || 1;
    const width = window.innerWidth;
    const height = window.innerHeight;
    const size = Math.max(width, height);

    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);

    // Load GSAP and start animation
    await loadGSAP();
    const gsap = (window as any).gsap;

    if (!gsap) {
      console.error('GSAP failed to load');
      return;
    }

    const controller = new SpiralController(canvas, ctx, size);
    controller.startAnimation(gsap);

    // UI Animation
    let step = 0;
    const animationTimers: number[] = [];

    function animateStep() {
      step++;
      if (step === 1) {
        decoLine?.classList.add('visible');
        subtitle?.classList.add('visible');
        progressContainer?.classList.add('visible');
        skipBtn?.classList.add('visible');
      }
      words.forEach((word, i) => {
        if (step > i) word.classList.add('visible');
      });
    }

    // Start UI animation sequence
    const initialDelay = 500;
    const firstTimer = window.setTimeout(() => animateStep(), initialDelay);
    animationTimers.push(firstTimer);

    words.forEach((_, i) => {
      const timer = window.setTimeout(() => animateStep(), initialDelay + 200 + i * 100);
      animationTimers.push(timer);
    });

    // Dismiss function
    function dismiss() {
      overlay.classList.add('fading');
      setTimeout(() => {
        overlay.classList.add('hidden');
        controller.destroy();
      }, 800);
    }

    // Auto-dismiss
    const autoDismissTimer = window.setTimeout(dismiss, duration);
    animationTimers.push(autoDismissTimer);

    // Skip button
    skipBtn?.addEventListener('click', () => {
      animationTimers.forEach(t => clearTimeout(t));
      dismiss();
    });
  }

  // Run on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSpiralIntro);
  } else {
    initSpiralIntro();
  }

  // Handle Astro view transitions
  document.addEventListener('astro:page-load', initSpiralIntro);
</script>
